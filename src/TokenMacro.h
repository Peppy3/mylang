// X macro of all the tokens
X(eof)
X(invalid)

X(eq)	// ==
X(neq)	// !=
X(lt)	// <
X(gt)	// >
X(lte)	// <=
X(gte)	// >=

X(bool_not) // not
X(bool_and) // and
X(bool_or)	// or

X(inc)	// ++
X(dec)	// --

X(add)		// +
X(sub)		// -
X(asterisk)	// *
X(div)		// /
X(mod)		// %

X(not)			// ~
X(xor)			// ^
X(ampersand)	// &
X(or)			// |

X(shl)	// <<
X(shr)	// >>

X(period)	// .
X(ellipsis)	// ...
X(arrow)	// ->
X(comma)	// ,

X(semicolon)	// ;
X(colon)		// :
X(at)			// @

X(assignment)	// =
X(assign_add)	// +=
X(assign_sub)	// -=
X(assign_mul)	// *=
X(assign_div)	// /=
X(assign_mod)	// %=
X(assign_shl)	// <<=
X(assign_shr)	// >>=

X(assign_not)	// ~=
X(assign_xor)	// ^=
X(assign_and)	// &=
X(assign_or)	// |=

X(lparen)	// (
X(rparen)	// )
X(lcurly)	// {
X(rcurly)	// }
X(lsquare)	// [
X(rsquare)	// ]

X(if)
X(else)

X(switch)
X(case)
X(default)

X(while)
X(do)
X(for)
X(continue)
X(break)
X(return)

X(pub)
X(const)
X(lin)
X(extern)
X(inline)
X(export)
X(linkname)

X(struct)
X(union)
X(enum)

X(null)
X(true)
X(false)

X(TYPE_START)
X(int)
X(uint)
X(TYPE_END)

X(LITERAL_START)
X(identifier)
X(integer)
X(hexadecimal)
X(float_lit)
X(string)
X(char_lit)
X(LITERAL_END)
