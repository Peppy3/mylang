
/* Compiler directives start with an '@' symbol */
const str: any = @import("string");
const io := @import("io");
const mem := @import("memory");
const int_size: ulong = @sizeof(int);
@warn("This is a warning");

@assert(true, "This is surely a true statement (get it? the statement is 'true')" );

// Basic Hello World program
// argv is a pointer to an array of pointers to char arrays
func main(void): int {
	// arrays are not bounds checked, string literals ends in a null character ( '\0' )
	const hii: []char = "Hello, World!";
	io.puts(hii);
	return 0;
}

// dual return values
func add2to2(x: i32, y: i32): i32, i32 {
	x += 2;
	y += 2;
	return x, y;
}

/*
 * Regular types
 * 
 * i8    // signed 1 byte
 * u8    // unsigned 1 byte
 * i16   // signed 2 bytes
 * u16   // unsigned 2 bytes
 * i32   // signed 4 bytes
 * u32   // unsigned 4 bytes
 * i64   // signed 8 bytes
 * u64   // unsigned 8 bytes
 * i128  // signed 16 byte
 * u128  // unsigned 16 byte
 * 
 * bool  // true or false
 * char  // alias for u8
 * int   // alias for i32
 * uint  // alias for u32
 * long  // alias for i64
 * ulong // alias for u64
 *
 * uintptr // a type big enough to hold a pointer
 *
 * f32   // 32 bit floating point
 * f64   // 64 bit floating point
 * f128  // 128 bit floating point
 * 
 * any  // any type, is not a pointer
 * type // the type of a type is a type
 * void // null, nothing, nada
 * 
 */

// functions are not exported by default
export func mul(x: int, y: int): int {
	return x * y;
}

// defining an external function
extern func memset(dest: any[], c: int, count: ulong) any[];

// structs (are not C structs if extern specifier is not used)
struct String {
	// str is public
	export var str: []char;
	var len: u64;
	var size: u64;
}

// struct methods
export func String.init(s: char[]): String {
	if (s == nil) {
		s = mem.alloc(24, char);
		return : String = {s, 0, 24};
	}
	var len: u64 = str.len(s);
	var size: u64 = (len & (24 - 1)) + 24;
	var dest: []char = mem.alloc(size, char);

	// sneaky C function
	memset(dest, 0, size); 

	mem.copy(dest, s, len);

	// return and denote that this is a String
	return : String = {.str = dest, .len = len, .size = size};
}

// will always return nil, no matter what (can only do this with constants
export func String.destroy(s: String): nil {
	mem.free(s.str);
}

export func String.cmp(self: String, other: String): int {
	var r: int = 0;
	
	// regular C style for loop (while and do while loops work as expected too)
	for (var i := 0; (self.str[i] != '\0') || (other.str[i] != '\0'); i++) {
		if ( r = self.str[i] - other.str[i]) return r;
	}
	return -1;
}

// const functions are for functions that do not need to be evaluated at runtime
// a.k.a no side effects
export const func String.data(self: String, i: u64) []char {
	return self.str;
}

// any is a generic type for any kind of type (the type of a struct is its name)
// @typeof( any(String) ) == String
// the any type must be able to be known at compile time

// @sizeof(any) will give the size of the kind of type it refers to.
export struct Union {
	var u: any;
}

// A struct method wihtout a name is a convertion function
// There is no constructor or destrcutor. Use .init and .destroy if the struct needs to be destroyed after use
export const func Union.(u: const type): Union {
	return: Union = { u };
}

export func Union.unpack(self: Union): any {
	@assert(self.hasValue());
	return self.u;
}

// type casts  ( this is not a good implementation of Union.hasValue() )
export func Union.hasValue(self: Union) bool {
	return bool(self.u);
}

// if any struct has complies with an interface, it can be used with it
interface file {
    // reads size bytes from the file returns a pointer to dst
    func read(self: any, dst: *any, size: ulong) *any;

    // writes size bytes from src to the file
    func write(self: any, src: *any, size: ulong) void;
}

// inline assembly
// (write call for Linux x86_64)
func write(fd: int, str: *char[], size: int): int {
	@register("rdi", fd);
	@register("rsi", str);
	@register("rdx", size);
	var err: int;
	@register("rax", err);
	asm (
		"mov $1, rax\n\t"
		"syscall"
		: "rdi", "rsi", "rdx"
		: "rax"
		: "memory"
	 );
	return err;
	
}
